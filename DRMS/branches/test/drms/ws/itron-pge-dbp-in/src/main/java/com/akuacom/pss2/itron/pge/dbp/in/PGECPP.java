/*
 * www.akuacom.com - Automating Demand Response
 * 
 * com.akuacom.pss2.itron.pge.dbp.in.PGECPP.java - Copyright(c)1994 to 2010 by Akuacom . All rights reserved. 
 * Redistribution and use in source and binary forms, with or without modification, is prohibited.
 *
 */
package com.akuacom.pss2.itron.pge.dbp.in;

import java.io.IOException;
import java.io.PrintWriter;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.akuacom.pss2.core.EJBFactory;
import com.akuacom.pss2.event.Event;
import com.akuacom.pss2.event.EventManager;
import com.akuacom.pss2.event.participant.EventParticipant;
import com.akuacom.pss2.program.ProgramManager;
import com.akuacom.pss2.program.itron.ItronManager;

/**
 * The Class PGECPP.
 */
public class PGECPP extends HttpServlet {


    private static final PGECPP instance = new PGECPP();
	/** The Constant log. */
	private static final Logger log = Logger.getLogger(PGECPP.class.getName());

	// private String beginStr =
	// "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>";
	// private static final String beginStr = "<?xml version=";
	// private static final String endStr = "</Block></Job>";

	/*
	 * private String hackLine (String line) { String hackedLine = line; int
	 * begIndex = line.indexOf(beginStr); if (begIndex != -1) { hackedLine =
	 * line.substring(begIndex); }
	 * 
	 * int endIndex = hackedLine.lastIndexOf(endStr); if (endIndex != -1) {
	 * endIndex += endStr.length(); hackedLine = hackedLine.substring(0,
	 * endIndex); }
	 * 
	 * return hackedLine; }
	 */

	/** The Constant ZONE1_PROGRAM_NAME. */
	public static final String ZONE1_PROGRAM_NAME = "CPP - LBL Climate Zone 1";

	private EventManager eventManager = EJBFactory.getBean(EventManager.class);
	private ProgramManager programManager = EJBFactory.getBean(ProgramManager.class);

	// public static final byte TYPE_PGE_CPP_ZONE1 = 1;
	/** The Constant TYPE_UNKNOWN. */
	public static final byte TYPE_UNKNOWN = -1;

	/** The Constant TYPE_OPERATOR. */
	public static final byte TYPE_OPERATOR = 0;

	/** The Constant TYPE_CPP. */
	public static final byte TYPE_CPP = 1; // deprecated
	// public static final byte TYPE_PGE_CPP_ZONE2 = 2;
	/** The Constant EVENT_TYPE_1. */
	public static final byte EVENT_TYPE_1 = 1;

	/** The Constant EVENT_TYPE_2. */
	public static final byte EVENT_TYPE_2 = 2;// 2 more types added for autoDBP

	/** The Constant EVENT_TYPE_3. */
	public static final byte EVENT_TYPE_3 = 3;

	/** The Constant EVENT_TYPE_4. */
	public static final byte EVENT_TYPE_4 = 4;

	/** The Constant TYPE_TEST. */
	public static final byte TYPE_TEST = 3;

	/** The Constant SORT_NAME. */
	public static final int SORT_NAME = 0;

	/** The Constant SORT_TYPE. */
	public static final int SORT_TYPE = 1;

	// private static final String ZONE2_PROGRAM_NAME =
	// "CPP - LBL Climate Zone 2";
	// private static final String ZONE2_PROGRAM_NAME = "TWO_HOUR_TEST";
	// private String tempFileName1 = "pgecpp_itron1.xml";
	// private String tempFileName2 = "pgecpp_itron2.xml";

	/*
	 * public void doGet(HttpServletRequest request, HttpServletResponse
	 * response) throws ServletException, IOException { DocumentBuilderFactory
	 * factory = DocumentBuilderFactory.newInstance();
	 * 
	 * int errors = 0; try { String line; //first just receive input and save to
	 * file File f1 = new File(tempFileName1); BufferedWriter out1 = new
	 * BufferedWriter (new FileWriter(f1)); InputStream in =
	 * request.getInputStream(); BufferedReader bufr = new BufferedReader(new
	 * InputStreamReader(in)); while ( (line = bufr.readLine()) != null) {
	 * out1.write(line); } in.close(); out1.close();
	 * log.info("Done writing input to file");
	 * 
	 * // now read file1, apply hack and save to file2 BufferedReader fReader =
	 * new BufferedReader(new FileReader(tempFileName1)); File f2 = new
	 * File(tempFileName2); BufferedWriter out2 = new BufferedWriter (new
	 * FileWriter(f2)); String newLine; while ( (line = fReader.readLine()) !=
	 * null) { log.debug("before"+line); newLine = hackLine(line);
	 * log.debug("after"+newLine); out2.write(newLine); } fReader.close();
	 * out2.close(); log.debug("Done writing hacked input to file");
	 * 
	 * DocumentBuilder builder = factory.newDocumentBuilder(); Document document
	 * = builder.parse(f2 ); errors = parseDocument(document, list); } catch
	 * (SAXParseException spe) { // Error generated by the parser
	 * log.info("\n** Parsing error" + ", line " + spe.getLineNumber() +
	 * ", uri " + spe.getSystemId()); log.info("   " + spe.getMessage() );
	 * 
	 * log.fatal("SAXParseException", spe); errors++; } catch (SAXException sxe)
	 * { log.fatal("SAXException", sxe); errors++; } catch
	 * (ParserConfigurationException pce) { // Parser with specified options
	 * can't be built log.fatal("ParserConfigurationException", pce); errors++;
	 * } catch (IOException ioe) { // I/O error log.fatal("IOException", ioe);
	 * errors++; } PrintWriter out = response.getWriter();
	 * out.println("<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n" +
	 * "<Response>\n    <Errors>" + errors + "</Errors>\n</Response>"); }
	 */

	/**
	 * Parses the document.
	 * 
	 * @param document
	 *            the document
	 * @param list
	 *            the list
	 * 
	 * @return the int
	 */
	public int parseDocument(Document document, List<EventParticipant> list) {

		Date startDate = null;
		Date endDate = null;
		String itronProgramName = "";
		String programName = "PGECPP";
		String startDateStr = null;
		String endDateStr = null;
		String timeZone = null;
		String eventID = null;
		int errors = 0;
		String eventCondition = null;
		NodeList nodeList = document.getElementsByTagName("MessageArg");

		for (int i = 0; i < nodeList.getLength(); i++) {
			Node nameNode = findChildNodeName(nodeList.item(i), "Name");

			if (nameNode != null) {
				if (findChildNodeValue(nameNode, "ProgramName") != null) {

					Node valueNode = findChildNodeName(nodeList.item(i),
							"Value");
					if (valueNode != null) {
						itronProgramName = findFirstValue(valueNode);
					}

				} else if (findChildNodeValue(nameNode, "EventID") != null) {
					Node valueNode = findChildNodeName(nodeList.item(i),
							"Value");
					if (valueNode != null) {
						eventID = findFirstValue(valueNode);
					}
				} else if (findChildNodeValue(nameNode, "EventStartDate") != null) {

					Node valueNode = findChildNodeName(nodeList.item(i),
							"Value");
					if (valueNode != null) {
						// startDate = new
						// SimpleDateFormat("MM/dd/yyyy HH:mm z").parse(findFirstValue(valueNode));

						String str = findFirstValue(valueNode);
						startDateStr = str.replace('T', ' ');
					}

				} else if (findChildNodeValue(nameNode, "EventEndDate") != null) {

					Node valueNode = findChildNodeName(nodeList.item(i),
							"Value");
					if (valueNode != null) {
						// endDate = new
						// SimpleDateFormat("MM/dd/yyyy HH:mm z").parse(findFirstValue(valueNode));
						String str = findFirstValue(valueNode);
						endDateStr = str.replace('T', ' ');
					}

				} else if (findChildNodeValue(nameNode, "TimeZone") != null) {

					Node valueNode = findChildNodeName(nodeList.item(i),
							"Value");
					if (valueNode != null) {
						timeZone = findFirstValue(valueNode);
					}
				}  else if (findChildNodeValue(nameNode, "EventCondition") != null) {
					Node valueNode = findChildNodeName(nodeList.item(i),
							"Value");
					if (valueNode != null) {
						eventCondition = findFirstValue(valueNode);
					}
				}
			}
		}

		// must wait till TImeZone is read and set to formatter
		DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

		try {
			// log.info("Setting timezone to "+timeZone);
			// df.setTimeZone(TimeZone.getTimeZone(timeZone));
			if (startDateStr != null) {
				startDate = df.parse(startDateStr);
			}
			if (endDateStr != null) {
				endDate = df.parse(endDateStr);
			}
		} catch (ParseException pe) {
			// Date parse exception
			// log.fatal(pe);
			errors++;
			log.fatal("ParseException", pe);
		}

		log.debug("StartDate: " + startDate);
		log.debug("EndDate: " + endDate);
		log.debug("TimeZone: " + timeZone);

		if (programName == null) {
			log.error("ProgramName is null");
			errors++;
		}
		if (startDate == null) {
			log.error("startDate is null");
			errors++;
		}
		if (endDate == null) {
			log.error("endDate is null");
			errors++;
		}
		if(eventCondition == null){
			log.error("eventCondition is null");
			errors++;
		}
		if(eventCondition.equals("EventCancellation")){
			if(eventID == null){
				log.error("EventID is null");
				errors++;
			} else {
				Event event = (Event)
						eventManager.getEvent(programName, eventID);
				if(event == null){
					log.error("Event does not exist");
					errors++;
				}
			}
		}

		if (errors == 0  && !eventCondition.equals("EventCancellation")) {
			// check if event time is in past, if yes, don't accept
			Date now = new Date();
			if (startDate.before(now)) {
				log.error("Cannot create event in past!");
				errors++;
			}
		}

		if (errors == 0) {
			byte program = TYPE_UNKNOWN;
			if (itronProgramName.equals(ZONE1_PROGRAM_NAME)) {
				programName = "CPP";
				program = EVENT_TYPE_1;
				log.debug("Calling to process the event for program:" + program);
				errors = process(startDate, endDate, programName, eventID, list);
			} else if (itronProgramName.startsWith("PDP")) {
				programName = programManager.getProgramFromUtilityProgramName(
						itronProgramName).getProgramName();
				program = EVENT_TYPE_1;
				log.debug("Calling to process the event for program:" + program);
				log.debug("Calling to process the event for program:" + program);
				if(eventCondition.equalsIgnoreCase("EventCancellation")){
					errors = cancelEvent(programName, eventID);
				} else {
					errors = process(startDate, endDate, programName, eventID, list);
				}
			} else if (program == TYPE_UNKNOWN) {
				// todo: log error to log4j
				log.error("Unknow progrs/channelType: " + program);
				errors++;
			}
		}

		return errors;

	}

	/*
	 * public void doPost(HttpServletRequest request, HttpServletResponse
	 * response) throws ServletException, IOException { doGet(request,
	 * response); }
	 */

	/**
	 * Process.
	 * 
	 * @param start
	 *            the start
	 * @param end
	 *            the end
	 * @param programName
	 *            the program name
	 * @param eventID
	 *            the event id
	 * @param list
	 *            the list
	 * 
	 * @return the int
	 */
	public int process(Date start, Date end, String programName,
			String eventID, List<EventParticipant> list) {
		// Create an EventCore and send to programManager
		try {
			Event event = new Event();

			event.setProgramName(programName);

			Date now = new Date();
			event.setEventName(eventID);
			event.setIssuedTime(new Date(now.getTime() + 60000));
			event.setStartTime(start);
			event.setEndTime(end);
			event.setReceivedTime(now);
			
			if (list != null)
				event.setParticipants(list);
			
			ItronManager itronManager = EJBFactory.getBean(ItronManager.class);
			itronManager.createEvent(programName, event);
			
		} catch (Exception e) {
			log.info(e);
			return 1;
		}
		return 0;
	}
	
	public int cancelEvent(String programName,
			String eventID) {
		// Create an EventCore and send to programManager
		try {
			ItronManager itronManager = EJBFactory.getBean(ItronManager.class);
			itronManager.cancelEvent(programName, eventID);
			
		} catch (Exception e) {
			log.info(e);
			return 1;
		}
		return 0;
	}

	/**
	 * Find first value.
	 * 
	 * @param node
	 *            the node
	 * 
	 * @return the string
	 */
	protected static String findFirstValue(Node node) {
		NodeList nodeList = node.getChildNodes();
		for (int i = 0; i < nodeList.getLength(); i++) {
			if (nodeList.item(i).getNodeValue() != null
					&& Character.isLetterOrDigit(nodeList.item(i)
							.getNodeValue().charAt(0))) {
				return nodeList.item(i).getNodeValue();
			}
		}
		return null;
	}

	/**
	 * Find child node name.
	 * 
	 * @param node
	 *            the node
	 * @param name
	 *            the name
	 * 
	 * @return the node
	 */
	protected Node findChildNodeName(Node node, String name) {
		if (node == null) {
			return null;
		}
		NodeList nodeList = node.getChildNodes();
		for (int i = 0; i < nodeList.getLength(); i++) {
			if (nodeList.item(i).getNodeName().equals(name)) {
				return nodeList.item(i);
			}
		}
		return null;
	}

	/**
	 * Find child node value.
	 * 
	 * @param node
	 *            the node
	 * @param name
	 *            the name
	 * 
	 * @return the node
	 */
	protected Node findChildNodeValue(Node node, String name) {
		if (node == null) {
			return null;
		}
		NodeList nodeList = node.getChildNodes();
		for (int i = 0; i < nodeList.getLength(); i++) {
			if (nodeList.item(i).getNodeValue().equals(name)) {
				return nodeList.item(i);
			}
		}
		return null;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * javax.servlet.http.HttpServlet#doGet(javax.servlet.http.HttpServletRequest
	 * , javax.servlet.http.HttpServletResponse)
	 */
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		log.debug("***** START ProgramInputServlet *****");
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

		int errors = parseRequest(factory, request, response);

		if (errors == 0) {
			errors = process();
		}
		sendResponse(errors, request, response);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest
	 * , javax.servlet.http.HttpServletResponse)
	 */
	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}// for dbp override this for custom response format

	/**
	 * Send response.
	 * 
	 * @param errors
	 *            the errors
	 * @param request
	 *            the request
	 * @param response
	 *            the response
	 * 
	 * @throws ServletException
	 *             the servlet exception
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 */
	protected void sendResponse(int errors, HttpServletRequest request,
			HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		out.println("<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n"
				+ "<Response>\n    <Errors>" + errors
				+ "</Errors>\n</Response>");
	}

	/**
	 * Process.
	 * 
	 * @return the int
	 */
	protected int process() {
		return 0;
	}

	/**
	 * Parses the request.
	 * 
	 * @param factory
	 *            the factory
	 * @param request
	 *            the request
	 * @param response
	 *            the response
	 * 
	 * @return the int
	 */
	protected int parseRequest(DocumentBuilderFactory factory,
			HttpServletRequest request, HttpServletResponse response) {
		return 0;
	}
	
	
	@Override
	public void init(ServletConfig config) throws ServletException {
		super.init(config);
	}
	
	public static PGECPP getInstance() {
		return instance;
	}

}
