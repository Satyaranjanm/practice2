/*
 * www.akuacom.com - Automating Demand Response
 *
 * com.akuacom.pss2.utilopws.UtilityOperatorWS.java - Copyright(c)1994 to 2010 by Akuacom . All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification, is prohibited.
 *
 */
package com.akuacom.pss2.utilopws;

import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import javax.ejb.EJB;
import javax.ejb.EJBException;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.xml.ws.Holder;
import javax.xml.ws.RequestWrapper;
import javax.xml.ws.ResponseWrapper;

import org.apache.log4j.Logger;
import org.jboss.ws.annotation.SchemaValidation;
import org.openadr.dras.bid.ListOfBids;
import org.openadr.dras.drasclient.CommsStatus;
import org.openadr.dras.drasclient.ListOfCommsStatus;
import org.openadr.dras.eventstate.ListOfEventStates;
import org.openadr.dras.feedback.ListOfFeedback;
import org.openadr.dras.logs.ListOfDRASClientAlarms;
import org.openadr.dras.logs.ListOfTransactionLogs;
import org.openadr.dras.participantaccount.ListOfParticipantAccountIDs;
import org.openadr.dras.participantaccount.ListOfParticipantAccounts;
import org.openadr.dras.participantaccount.ParticipantAccount;
import org.openadr.dras.programconstraint.ConstraintFilter;
import org.openadr.dras.programconstraint.DateTimeWindow;
import org.openadr.dras.programconstraint.ProgramConstraint;
import org.openadr.dras.utilitydrevent.ListOfEventIDs;
import org.openadr.dras.utilitydrevent.ListOfUtilityDREvents;
import org.openadr.dras.utilitydrevent.UtilityDREvent;
import org.openadr.dras.utilityoperator.UtilityOperator;
import org.openadr.dras.utilityprogram.ListOfIDs;
import org.openadr.dras.utilityprogram.ListOfProgramNames;
import org.openadr.dras.utilityprogram.ListOfPrograms;
import org.openadr.dras.utilityprogram.ParticipantList;
import org.openadr.dras.utilityprogram.UtilityProgram;

import com.akuacom.ejb.client.EJB3Factory;
import com.akuacom.pss2.client.ClientManager;
import com.akuacom.pss2.client.ClientStatus;
import com.akuacom.pss2.core.EJBFactory;
import com.akuacom.pss2.core.ErrorResourceUtil;
import com.akuacom.pss2.core.ErrorUtil;
import com.akuacom.pss2.core.FireLogReaderBean;
import com.akuacom.pss2.core.ValidationException;
import com.akuacom.pss2.event.Event;
import com.akuacom.pss2.event.EventInfo;
import com.akuacom.pss2.event.EventManager;
import com.akuacom.pss2.event.EventManagerBean;
import com.akuacom.pss2.event.participant.EventParticipant;
import com.akuacom.pss2.participant.Participant;
import com.akuacom.pss2.participant.ParticipantExtInfo;
import com.akuacom.pss2.participant.ParticipantManager;
import com.akuacom.pss2.participant.ParticipantManagerBean;
import com.akuacom.pss2.program.Program;
import com.akuacom.pss2.program.ProgramManager;
import com.akuacom.pss2.program.ProgramManagerBean;
import com.akuacom.pss2.program.bidding.BiddingProgramManager;
import com.akuacom.pss2.program.dbp.Bid;
import com.akuacom.pss2.program.dbp.BidEntry;
import com.akuacom.pss2.program.dbp.DBPEvent;
import com.akuacom.pss2.program.participant.ProgramParticipantManager;
import com.akuacom.pss2.program.participant.ProgramParticipantManagerBean;
import com.akuacom.pss2.system.SystemManager;
import com.akuacom.pss2.system.SystemManagerBean;
import com.akuacom.pss2.util.DateTool;
import com.akuacom.pss2.util.EventState;
import com.akuacom.pss2.util.LogUtils;
import com.kanaeki.firelog.util.FireLogEntry;

/**
 * This class was generated by the JAX-WS RI. JAX-WS RI 2.1.1-b03- Generated
 * source version: 2.0
 */
@WebService(name = "UtilityOperator", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", wsdlLocation = "WEB-INF/wsdl/UtilityOperatorWSService.wsdl")
public class UtilityOperatorWS implements UtilityOperator {

    /**
     * This function is implemented on the DRAS and is used by the Utility/ISO
     * to initiate a DR Event. All the event information is passed in concerning
     * the event along with a specification of the Participants that should
     * receive the event. In the case where bidding is required as part of the
     * Program then this method call will initiate the bidding process. Before
     * the Utility/ISO can issue a DR Event it is assumed that all the relevant
     * information concerning the DR Program and Participants has been
     * configured. Once the DR Event is initiated by the Utility/ISO the DR Event
     * information will be sent to the Participants at the appropriate time
     * depending upon whether the Participant is configured to use a Smart DRAS
     * Client or a Simple DRAS Client. For more information on this mechanism see
     * the section concerning the event propagation model. It is possible to call
     * this method numerous times and initiate a DR Events with the same e
     * Authorized Users: - All DRAS Operators - All Utility/ISO Operators
     */

    private static final Logger log = Logger.getLogger(UtilityOperatorWS.class);

    /** The program manager. */
    private EventManager.L _eventManager = EJB3Factory
            .getLocalBean(EventManagerBean.class);

    private ParticipantManager.L participantManager = EJB3Factory
            .getLocalBean(ParticipantManagerBean.class);

    private ProgramParticipantManager.L programParticipantManager = EJB3Factory
            .getLocalBean(ProgramParticipantManagerBean.class);

    private SystemManager.L systemManager = EJB3Factory
            .getLocalBean(SystemManagerBean.class);

    private ProgramManager.L programManager1 = EJB3Factory
            .getLocalBean(ProgramManagerBean.class);

    /** The dbp data access. */
    @EJB
    private BiddingProgramManager.L dbpDataAccess;

    /*
     * (non-Javadoc)
     * 
     * @see
     * org.openadr.dras.utilityoperator.UtilityOperator#initiateDREvent(org.
     * openadr.dras.utilitydrevent.UtilityDREvent, javax.xml.ws.Holder,
     * javax.xml.ws.Holder)
     */
    @WebMethod(operationName = "InitiateDREvent", action = "http://www.openadr.org/DRAS/UtilityOperator/InitiateDREvent")
    @RequestWrapper(localName = "InitiateDREvent", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.InitiateDREvent")
    @ResponseWrapper(localName = "InitiateDREventResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.InitiateDREventResponse")
    public void initiateDREvent(
            @WebParam(name = "DR_Event", targetNamespace = "") org.openadr.dras.utilitydrevent.UtilityDREvent drEvent,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue,
            @WebParam(name = "constraintValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<org.openadr.dras.programconstraint.ConstraintFilter> constraintValue) {
        String retCode = "FAILURE: ";
        ConstraintFilter ret = ConstraintFilter.REJECT;

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setDescription("SUCCESS");
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        logEntry.setLongDescr(StringUtil.createLongDesc(drEvent,
                "DESCRIPTION_UO_initiateDREvent"));

        try {
            _eventManager.createEvent(drEvent, false);
            ret = ConstraintFilter.ACCEPT;
            retCode = "SUCCESS";
        } catch (Exception e) {
            log.error("initiateDREvent failed", e);
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();

        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        returnValue.value = retCode;
        constraintValue.value = ret;
    }

    /**
     * This function is used to edit a previously issued DR Event. It must
     * reference the DR Event id that was assigned by the Utility/ISO when the
     * event was issued.
     * 
     * The following types of modifications can be made to an already initiated
     * DR Event:
     * 
     * - Cancel a DR Event. This will immediately cancel a pending DR event. If
     * the DR Event information has already been sent to the Participants then a
     * message will be sent which notifies them of the change in the DR Event. A
     * DR Event can be cancelled at any time.
     * 
     * - Change the Participant list. This will modify the list of Participants
     * that will receive the DR Event. If there are Participants that have been
     * dropped off the list that have already been notified of the DR Event then
     * they will be sent messages by the DRAS notifying them that the DR Event
     * has been cancelled.
     * 
     * - Modify DR Event parameters. This will modify the parameters of an
     * already initiated DR Event. If the DR Event information has already been
     * sent to a Participant then that Participant will be sent the new
     * information.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param eventID
     *            the event id
     * @param drEvent
     *            the dr event
     * @param modificationType
     *            the modification type
     * @param returnValue
     *            the return value
     * @param constraintValue
     *            the constraint value
     * 
     *            returns programconstraint.ConstraintFilter
     */
    @WebMethod(operationName = "ModifyDREvent", action = "http://www.openadr.org/DRAS/UtilityOperator/ModifyDREvent")
    @RequestWrapper(localName = "ModifyDREvent", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.ModifyDREvent")
    @ResponseWrapper(localName = "ModifyDREventResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.ModifyDREventResponse")
    public void modifyDREvent(
            @WebParam(name = "eventID", targetNamespace = "") String eventID,
            @WebParam(name = "modificationType", targetNamespace = "") String modificationType,
            @WebParam(name = "DR_Event", targetNamespace = "") UtilityDREvent drEvent,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue,
            @WebParam(name = "constraintValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ConstraintFilter> constraintValue) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        ConstraintFilter ret = null;
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    modificationType, drEvent, "DESCRIPTION_UO_modifyDREvent"));

            if ("CANCEL".equalsIgnoreCase(modificationType)) {
                Event event = _eventManager.getEventOnly(eventID);
                if (event != null) {
                    String progName = event.getProgramName();
                    _eventManager.removeEvent(progName, eventID);
                    ret = ConstraintFilter.ACCEPT;
                    retCode = "SUCCESS";
                } else {
                    ret = ConstraintFilter.REJECT;
                    retCode = "SUCCESS";
                }
            } else if ("PARTICIPANTS".equalsIgnoreCase(modificationType)) {
                // programManager.updateEventParticipants(); //TODO 0313
                ret = ConstraintFilter.REJECT;
                String error = ErrorResourceUtil.getErrorMessage(
                        "ERROR_EVENT_CHANGE_NOT_ALLOWED", eventID);
                throw new Exception(error);
            } else if ("MODIFY".equalsIgnoreCase(modificationType)) {
                Event event = _eventManager.getEventWithParticipantsAndSignals(eventID);
                if (event != null) {
                    _eventManager.updateEvent(event.getProgramName(),
                            event.getEventName(), event, drEvent);
                    ret = ConstraintFilter.ACCEPT;
                    retCode = "SUCCESS";
                } else {
                    ret = ConstraintFilter.REJECT;
                    retCode = "SUCCESS";
                }
            }
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();

        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        constraintValue.value = ret;
        returnValue.value = retCode;
    }

    /**
     * This function will modify the list of Participants that will receive an
     * already existing DR Event. If there are Participants that have been
     * dropped off the list that have already been notified of the DR Event then
     * they will be sent messages by the DRAS notifying them that the DR Event
     * has been cancelled.
     * 
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param addParticipants
     *            the add participants
     * @param eventID
     *            the event id
     * @param participantList
     *            the participant list
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "AdjustDREventParticipants", action = "http://www.openadr.org/DRAS/UtilityOperator/AdjustDREventParticipants")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "AdjustDREventParticipants", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.AdjustDREventParticipants")
    @ResponseWrapper(localName = "AdjustDREventParticipantsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.AdjustDREventParticipantsResponse")
    public String adjustDREventParticipants(
            @WebParam(name = "eventID", targetNamespace = "") String eventID,
            @WebParam(name = "addParticipants", targetNamespace = "") boolean addParticipants,
            @WebParam(name = "participantList", targetNamespace = "") ParticipantList participantList) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    "DESCRIPTION_UO_adjustDREventParticipants"));

            List<String> parameters = new ArrayList<String>();
            parameters.add(eventID);
            String error = ErrorResourceUtil.getErrorMessage(
                    "ERROR_EVENT_CHANGE_PARTICIPANT_NOT_ALLOWED", parameters);
            // todo 0313 part of modifyDREvent
            throw new Exception(error);
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;
    }

    /**
     * This function is used to get information related to currently pending or
     * active DR Events within the DRAS. There are a number of keys that may be
     * used to specify which Utility DR Event objects are returned. A Utility DR
     * Event object is returned if it satisfies all of the search criteria
     * specified in the list of parameters.
     * 
     * Note that if none of the search keys are specified then all pending or
     * active Utility DR Event entities are returned.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param eventID
     *            the event id
     * @param participants
     *            the participants
     * @param programNames
     *            the program names
     * @param drEvents
     *            the dr events
     * @param returnValue
     *            the return value
     * 
     *            returns utilitydrevent.ListOfUtilityDREvents
     */
    @WebMethod(operationName = "GetDREventInformation", action = "http://www.openadr.org/DRAS/UtilityOperator/GetDREventInformation")
    @RequestWrapper(localName = "GetDREventInformation", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDREventInformation")
    @ResponseWrapper(localName = "GetDREventInformationResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDREventInformationResponse")
    public void getDREventInformation(
            @WebParam(name = "eventID", targetNamespace = "") ListOfEventIDs eventID,
            @WebParam(name = "programNames", targetNamespace = "") ListOfProgramNames programNames,
            @WebParam(name = "participants", targetNamespace = "") ParticipantList participants,
            @WebParam(name = "DREvents", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfUtilityDREvents> drEvents,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        // todo 0313 programmanage will provide a method for each fitler list.
        // then hook
        String retCode = "FAILURE: ";
        ListOfUtilityDREvents ret = new ListOfUtilityDREvents();

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        List<Event> progEventList = new ArrayList<Event>();
        try {
            if (programNames == null)
                programNames = new ListOfProgramNames();
            if (participants == null)
                participants = new ParticipantList();
            if (eventID == null)
                eventID = new ListOfEventIDs();
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    programNames, participants,
                    "DESCRIPTION_UO_getDREventInformation"));

            List<EventInfo> events = new ArrayList<EventInfo>();

            if (programNames == null || programNames.getProgramID() == null
                    || programNames.getProgramID().size() == 0) {
                List<String> progNames = programManager1.getPrograms();
                programNames.getProgramID().addAll(progNames);
            }

            for (String progId : programNames.getProgramID()) {
                List<EventInfo> eventList1 = systemManager.lookupProgramBean(
                        progId).getEvents(progId);
                for (EventInfo event : eventList1) {
                    if (programNames != null
                            && programNames.getProgramID() != null
                            && programNames.getProgramID().size() > 0) {
                        if (programNames.getProgramID().contains(
                                event.getProgramName())) {
                            events.add(event);
                        }
                    } else {
                        events.add(event);
                    }
                }
            }

            if (participants != null && participants.getAccounts() != null
                    && participants.getAccounts().getParticipantID() != null
                    && participants.getAccounts().getParticipantID().size() > 0) {
                List<String> partIds = participants.getAccounts()
                        .getParticipantID();
                for (EventInfo event : events) {
                    Event progEvent = systemManager.lookupProgramBean(
                            event.getProgramName()).getEvent(
                            event.getProgramName(), event.getEventName());
                    List<EventParticipant> eveParts = progEvent
                            .getParticipants();
                    for (EventParticipant evePart : eveParts) {
                        if (partIds.contains(evePart.getParticipant()
                                .getAccountNumber())
                                && !progEventList.contains(progEvent)) {
                            progEventList.add(progEvent);
                        }
                    }
                }
            } else {
                for (EventInfo event : events) {
                    Event progEvent = systemManager.lookupProgramBean(
                            event.getProgramName()).getEvent(
                            event.getProgramName(), event.getEventName());
                    progEventList.add(progEvent);
                }
            }

            ret = BeanMappingUtil.getListOfUtilityDREvents(progEventList);
            retCode = "SUCCESS";
            returnValue.value = retCode;
            drEvents.value = ret;
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        drEvents.value = ret;
        returnValue.value = retCode;
    }

    /**
     * This function is used to create one or more Participant Accounts.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param participantAccounts
     *            the participant accounts
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "CreateParticipantAccounts", action = "http://www.openadr.org/DRAS/UtilityOperator/CreateParticipantAccounts")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "CreateParticipantAccounts", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.CreateParticipantAccounts")
    @ResponseWrapper(localName = "CreateParticipantAccountsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.CreateParticipantAccountsResponse")
    public String createParticipantAccounts(
            @WebParam(name = "participantAccounts", targetNamespace = "") ListOfParticipantAccounts participantAccounts) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {

            logEntry.setLongDescr(StringUtil.createLongDesc(
                    participantAccounts,
                    "DESCRIPTION_UO_createParticipantAccounts"));
            if (participantAccounts == null) {
                String error = ErrorResourceUtil
                        .getErrorMessage("ERROR_CREATE_PARTICIPANT_EMPTY_INPUT");
                throw new Exception(error);
            }
            List<ParticipantAccount> listPA = participantAccounts
                    .getParticipantAccount();
            if (listPA.size() < 1) {
                String error = ErrorResourceUtil
                        .getErrorMessage("ERROR_CREATE_PARTICIPANT_EMPTY_INPUT");
                throw new Exception(error);
            }

            List<ParticipantExtInfo> paiList = BeanMappingUtil
                    .getParticipantExtInfoList(participantAccounts);
            participantManager.createParticipantAccount(paiList);
            retCode = "SUCCESS";
        } catch (Exception e) {
            ValidationException ve = ErrorUtil.getValidationException(e);
            String msg;
            if (ve != null)
                msg = ve.getMessage();
            else
                msg = e.getMessage();
            logEntry.setDescription(msg);
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }

        return retCode;
    }

    /**
     * This function is used modify existing Participant Accounts.
     * 
     * Authorized Users
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param participantAccounts
     *            the participant accounts
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "ModifyParticipantAccounts", action = "http://www.openadr.org/DRAS/UtilityOperator/ModifyParticipantAccounts")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "ModifyParticipantAccounts", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.ModifyParticipantAccounts")
    @ResponseWrapper(localName = "ModifyParticipantAccountsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.ModifyParticipantAccountsResponse")
    public String modifyParticipantAccounts(
            @WebParam(name = "participantAccounts", targetNamespace = "") ListOfParticipantAccounts participantAccounts) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(
                    participantAccounts,
                    "DESCRIPTION_UO_modifyParticipantAccounts"));
            if (participantAccounts == null) {
                String error = ErrorResourceUtil
                        .getErrorMessage("ERROR_UPDATE_PARTICIPANT_EMPTY_INPUT");
                throw new Exception(error);
            }
            // TODO lin: currently, we assume all the attributes in participant
            // was populated before updating. update will update all fields.
            // need to confirm if we should simply take the populated field in
            // participantAccount and only updates those fields.
            // TODO lin: Still need to populate the all the values to make sure
            // all the fields not in participantAccount won't get lost after
            // this update.
            List<ParticipantAccount> list = participantAccounts
                    .getParticipantAccount();

            List<ParticipantExtInfo> paiList = new ArrayList<ParticipantExtInfo>();
            for (ParticipantAccount pa : list) {
                String acctID = pa.getAccountID();
                Participant part = null;
                try {
                    part = participantManager.getParticipantByAccount(acctID);
                } catch (EJBException e) {
                    String error = ErrorResourceUtil.getErrorMessage(
                            "ERROR_PARTICIPANT_NOT_EXIST", acctID);
                    throw new Exception(error);

                }
                if (part == null) {
                    String error = ErrorResourceUtil.getErrorMessage(
                            "ERROR_PARTICIPANT_NOT_EXIST", acctID);
                    throw new Exception(error);
                } else {
                    ParticipantExtInfo partExt = BeanMappingUtil
                            .getParticipantExtInfo(pa, part);
                    paiList.add(partExt);
                }
            }
            participantManager.updateParticipantAccount(paiList);
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }

        return retCode;
    }

    /**
     * Description This function is used to delete Participant Accounts that
     * were created with the CreateParticipantAccounts function.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param participantAccountIDs
     *            the participant account i ds
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "DeleteParticipantAccounts", action = "http://www.openadr.org/DRAS/UtilityOperator/DeleteParticipantAccounts")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "DeleteParticipantAccounts", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.DeleteParticipantAccounts")
    @ResponseWrapper(localName = "DeleteParticipantAccountsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.DeleteParticipantAccountsResponse")
    public String deleteParticipantAccounts(
            @WebParam(name = "participantAccountIDs", targetNamespace = "") ListOfParticipantAccountIDs participantAccountIDs) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(
                    participantAccountIDs,
                    "DESCRIPTION_UO_deleteParticipantAccounts"));
            if (participantAccountIDs == null) {
                String error = ErrorResourceUtil
                        .getErrorMessage("ERROR_DELETE_PARTICIPANT_EMPTY_INPUT");
                throw new Exception(error);
            }
            List<String> parList = participantAccountIDs
                    .getParticipantAccountID();
            participantManager.removeParticipantsByAccountNumber(parList);
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }

        return retCode;
    }

    /**
     * This function is used to fetch all the ParticipantAccount objects that
     * satisfy the specified search criteria. The search crieria is specified by
     * a list of participant specifications (account id's, Utility Group names,
     * and locations) or by the name of the Programs that the
     * ParticipantAccounts may be assiciated with. Note that if no search
     * criteria is specified then all Participant Account objects are returned.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param participants
     *            the participants
     * @param programName
     *            the program name
     * @param participantAccounts
     *            the participant accounts
     * @param returnValue
     *            the return value
     * 
     *            returns participantaccount.ListOfParticipantAccounts
     */
    @WebMethod(operationName = "GetParticipantAccounts", action = "http://www.openadr.org/DRAS/UtilityOperator/GetParticipantAccounts")
    @RequestWrapper(localName = "GetParticipantAccounts", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetParticipantAccounts")
    @ResponseWrapper(localName = "GetParticipantAccountsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetParticipantAccountsResponse")
    public void getParticipantAccounts(
            @WebParam(name = "participants", targetNamespace = "") ParticipantList participants,
            @WebParam(name = "programName", targetNamespace = "") String programName,
            @WebParam(name = "participantAccounts", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfParticipantAccounts> participantAccounts,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        ListOfParticipantAccounts ret = new ListOfParticipantAccounts();

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        // TODO lin as of 08/01/2008 we decided participantID maps to
        // participant object's accountNumber. participantName is the same as
        // username;

        // todo 0313 pm will provide new method to take list of part ids
        try {
            if (participants == null)
                participants = new ParticipantList();
            logEntry.setLongDescr(StringUtil.createLongDesc(participants,
                    programName, "DESCRIPTION_UO_getParticipantAccounts"));
            logEntry.setDescription("SUCCESS");
            List<Participant> partList = new ArrayList<Participant>();
            if (programName != null && !programName.equals("")) {
                List<String> participantListByProgram;
                participantListByProgram = programParticipantManager
                        .getParticipantsForProgram(programName);
                if (participantListByProgram != null
                        && participantListByProgram.size() > 0) {
                    for (String partStr : participantListByProgram) {
                        Participant part = participantManager
                                .getParticipant(partStr);
                        if (participants != null
                                && participants.getAccounts() != null
                                && participants.getAccounts()
                                        .getParticipantID().size() > 0) {
                            List<String> partIdList = participants
                                    .getAccounts().getParticipantID();
                            for (String partId : partIdList) {
                                if (partId.equals(part.getAccountNumber())) {
                                    partList.add(part);
                                }
                            }
                        } else {
                            partList.add(part);
                        }

                    }

                    List<Program> progList = new ArrayList<Program>();
                    progList.add(programManager1.getProgram(programName));
                    for (Participant partLista : partList) {
                        // List<EventState> eventStates =
                        // programManager.getParticipantEventStates(partLista.getUser());
                        ParticipantAccount pa = BeanMappingUtil
                                .getParticipantAccount(partLista, progList);
                        ret.getParticipantAccount().add(pa);
                    }
                }
            } else {
                List<String> partIdList = null;
                if (participants != null
                        && participants.getAccounts() != null
                        && participants.getAccounts().getParticipantID().size() > 0) {
                    partIdList = participants.getAccounts().getParticipantID();
                } else {
                    List<String> partNameList = participantManager
                            .getParticipants();
                    partIdList = new ArrayList<String>();
                    for (String partName : partNameList) {
                        partIdList.add(participantManager.getParticipant(
                                partName).getAccountNumber());
                    }

                }
                for (String partId : partIdList) {
                    Participant part = participantManager
                            .getParticipantByAccount(partId);

                    List<Program> progList = participantManager
                            .getProgramsForParticipantAsObject(part.getUser(),
                                    part.isClient());
                    // List<EventState> eventStates =
                    // programManager.getParticipantEventStates(part.getUser());

                    ParticipantAccount pa = BeanMappingUtil
                            .getParticipantAccount(part, progList);
                    ret.getParticipantAccount().add(pa);
                }
            }
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }

        participantAccounts.value = ret;
        returnValue.value = retCode;
    }

    /**
     * This function is used to create a new DR program.
     * 
     * Authorized Users: - All DRAS Operators - All Utility/ISO Operators
     * 
     * @param program
     *            the program
     * 
     * @return returns java.lang.String
     */
    @WebMethod(operationName = "CreateProgram", action = "http://www.openadr.org/DRAS/UtilityOperator/CreateProgram")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "CreateProgram", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.CreateProgram")
    @ResponseWrapper(localName = "CreateProgramResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.CreateProgramResponse")
    public String createProgram(
            @WebParam(name = "program", targetNamespace = "") UtilityProgram program) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);

        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(program,
                    "DESCRIPTION_UO_createProgram"));
            if (program == null) {
                String error = ErrorResourceUtil
                        .getErrorMessage("ERROR_CREATE_PROGRAM_EMPTY_INPUT");
                throw new Exception(error);
            }
            Program prog = programManager1.getProgramOnly(program.getName());
            if (prog != null) {
                // prorgam already exists
                List<String> parameters = new ArrayList<String>();
                parameters.add(prog.getProgramName());
                String error = ErrorResourceUtil.getErrorMessage(
                        "ERROR_CREATE_PROGRAM_ALREADY_EXIST", parameters);
                throw new Exception(error);
            }

            List<String> parameters = new ArrayList<String>();
            parameters.add("createProgram");
            String error = ErrorResourceUtil.getErrorMessage(
                    "ERROR_OPERATION_NOT_SUPPORTED", parameters);
            throw new Exception(error);

            // ProgramInfo progInfo =
            // BeanMappingUtil.getProgramExtInfo(program);
            // programManager.createProgram(progInfo);
            // retCode = "SUCCESS";
            // TODO lin: add log for successful scenario for all operators
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;
    }

    /**
     * This function is used to modify an existing Program that was created with
     * the CreateProgram function.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param program
     *            the program
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "ModifyProgram", action = "http://www.openadr.org/DRAS/UtilityOperator/ModifyProgram")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "ModifyProgram", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.ModifyProgram")
    @ResponseWrapper(localName = "ModifyProgramResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.ModifyProgramResponse")
    public String modifyProgram(
            @WebParam(name = "program", targetNamespace = "") UtilityProgram program) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(program,
                    "DESCRIPTION_UO_modifyProgram"));

            Program prog = programManager1.getProgram(program.getName());
            if (prog == null) {
                List<String> parameters = new ArrayList<String>();
                parameters.add(program.getName());
                String error = ErrorResourceUtil.getErrorMessage(
                        "ERROR_UPDATE_PROGRAM_NOT_EXIST", parameters);
                throw new Exception(error);
            }
            BeanMappingUtil.populateProgram(prog, program);
            programManager1.updateProgram(prog);
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;
    }

    /**
     * This function is used to delete an existing Program that was created with
     * the Create Program function. This function must fail if there is any
     * pending or active DR Events associated with this program. Any pending
     * events must be canceled or allowed to complete before deleting the
     * program.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param programName
     *            the program name
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "DeleteProgram", action = "http://www.openadr.org/DRAS/UtilityOperator/DeleteProgram")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "DeleteProgram", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.DeleteProgram")
    @ResponseWrapper(localName = "DeleteProgramResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.DeleteProgramResponse")
    public String deleteProgram(
            @WebParam(name = "programName", targetNamespace = "") String programName) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(programName,
                    "DESCRIPTION_UO_deleteProgram"));

            programManager1.removeProgram(programName);
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;
    }

    /**
     * This function is used to get all the information related to Programs
     * including the Program Constraints and Event Info Types associated with
     * the program. One of two keys may be used to specify which programs to
     * return. The first is a list of prgram names and the second is a list of
     * participants. Note that if none of the above keys are specified then all
     * UtilityProgram objects are returned.
     * 
     * Parameters There are a two different keys that may be used to specify
     * which Utility Program entities are returned.
     * 
     * - Program name(s) these are the names of programs that were created.
     * 
     * - Participant/group id(s) these are the specifications for the
     * participants that are associated with various programs.
     * 
     * 
     * Return Values
     * 
     * List of Utility Program objects that satisfy the search criteria
     * specified. The associated Program Constraints and Event Info Types for
     * each Utility Program object are also returned.
     * 
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param participants
     *            the participants
     * @param programNames
     *            the program names
     * @param programList
     *            the program list
     * @param returnValue
     *            the return value
     * 
     *            returns utilityprogram.ListOfPrograms
     */
    @WebMethod(operationName = "GetPrograms", action = "http://www.openadr.org/DRAS/UtilityOperator/GetPrograms")
    @RequestWrapper(localName = "GetPrograms", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetPrograms")
    @ResponseWrapper(localName = "GetProgramsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetProgramsResponse")
    public void getPrograms(
            @WebParam(name = "programNames", targetNamespace = "") ListOfProgramNames programNames,
            @WebParam(name = "participants", targetNamespace = "") ParticipantList participants,
            @WebParam(name = "programList", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfPrograms> programList,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";

        // todo 0313 pm provides new mthod for each fitler lists

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        ListOfPrograms ret = new ListOfPrograms();
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(programNames,
                    participants, "DESCRIPTION_UO_getPrograms"));
            logEntry.setDescription("SUCCESS");
            List<UtilityProgram> utilPrograms = new ArrayList<UtilityProgram>();
            if (participants != null && participants.getAccounts() != null
                    && participants.getAccounts().getParticipantID() != null
                    && participants.getAccounts().getParticipantID().size() > 0) {
                List<String> partIDs = participants.getAccounts()
                        .getParticipantID();
                for (String partID : partIDs) {
                    Participant part = participantManager
                            .getParticipantByAccount(partID);
                    List<Program> progs = participantManager
                            .getProgramsForParticipantAsObject(part.getUser(),
                                    part.isClient());
                    for (Program prog : progs) {
                        String progName = prog.getProgramName();

                        boolean canAdd = true;
                        /*
                         * for(UtilityProgram utilProg : utilProgs) { String
                         * utilProgName = utilProg.getName();
                         * if(prog.getProgramName().equals(utilProgName)) {
                         * added = true; } }
                         */
                        // TODO lin: there is no program id in program. treat it
                        // as program name now.
                        if (programNames.getProgramID() != null
                                && programNames.getProgramID().size() > 0) {
                            canAdd = false;
                            List<String> ids = programNames.getProgramID();
                            for (String id : ids) {
                                if (progName.equals(id)) {
                                    canAdd = true;
                                    break;
                                }
                            }
                        }
                        if (canAdd) {
                            Program progInfo = new Program();
                            List<String> parts = new ArrayList<String>();
                            parts.add(partID);
                            progInfo.setParticipants(parts);
                            UtilityProgram utilProg = BeanMappingUtil
                                    .getProgramUtil(progInfo);
                            utilPrograms.add(utilProg);
                        }
                    }
                }
            } else if (programNames != null
                    && programNames.getProgramID() != null
                    && programNames.getProgramID().size() > 0) {
                // TODO lin: there is no program id in program. treat it as
                // program name now.
                List<String> ids = programNames.getProgramID();
                for (String id : ids) {
                    Program prog = programManager1.getProgram(id);
                    List<Participant> parts = programParticipantManager
                            .getParticipantsForProgramAsObject(id);
                    List<String> accountIDs = new ArrayList<String>();
                    for (Participant part : parts) {
                        String partID = part.getAccountNumber();
                        accountIDs.add(partID);
                    }
                    prog.setParticipants(accountIDs);
                    UtilityProgram utilProg = BeanMappingUtil
                            .getProgramUtil(prog);
                    utilPrograms.add(utilProg);
                }
            } else
            // fetch all
            {
                List<String> progNames = programManager1.getPrograms();
                // TODO lin: there is no program id in program. treat it as
                // program name now.
                for (String name : progNames) {

                    Program prog = programManager1.getProgram(name);
                    List<Participant> parts = programParticipantManager
                            .getParticipantsForProgramAsObject(name);
                    List<String> accountIDs = new ArrayList<String>();
                    for (Participant part : parts) {
                        String partID = part.getAccountNumber();
                        accountIDs.add(partID);
                    }
                    prog.setParticipants(accountIDs);
                    UtilityProgram utilProg = BeanMappingUtil
                            .getProgramUtil(prog);
                    utilPrograms.add(utilProg);
                }
            }

            ret.getProgram().addAll(utilPrograms);
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        programList.value = ret;
        returnValue.value = retCode;

    }

    /**
     * Description This function is used to add or remove a Participant from a
     * program.
     * 
     * Authorized Users: - All DRAS Operators - All Utility/ISO Operators
     * 
     * @param participantList
     *            the participant list
     * @param addParticipants
     *            the add participants
     * @param programName
     *            the program name
     * 
     * @return returns java.lang.String
     */
    @WebMethod(operationName = "AdjustProgramParticipants", action = "http://www.openadr.org/DRAS/UtilityOperator/AdjustProgramParticipants")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "AdjustProgramParticipants", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.AdjustProgramParticipants")
    @ResponseWrapper(localName = "AdjustProgramParticipantsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.AdjustProgramParticipantsResponse")
    public String adjustProgramParticipants(
            @WebParam(name = "programName", targetNamespace = "") String programName,
            @WebParam(name = "addParticipants", targetNamespace = "") boolean addParticipants,
            @WebParam(name = "participantList", targetNamespace = "") ParticipantList participantList) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil
                    .createLongDesc(programName, participantList,
                            "DESCRIPTION_UO_adjustProgramParticipants"));

            if (participantList.getAccounts() != null) {
                List<String> partList = participantList.getAccounts()
                        .getParticipantID();
                if (addParticipants && partList != null && partList.size() > 0) {
                    programParticipantManager.addParticipantsToProgram(
                            programName, partList, false);
                } else if (!addParticipants && partList != null
                        && partList.size() > 0) {
                    programParticipantManager.removeParticipantsFromProgram(
                            programName, partList, false);
                }
            }
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;
    }

    /**
     * This function allows the Utility/ISO to request the current Participant
     * bids from the DRAS. The Utility/ISO can either request bids for a
     * specific event or all the standing bids for a specific UProgram. Either
     * an Event ID or a Program name, but not both should be specified. If an
     * Event ID is specified then the returned bid are only for those that
     * pertain to a specific DR Event and will include real time bids if any
     * have been submitted for that DR Event or the Participants standing bid if
     * no real time bids have been submitted for that event. If the program name
     * is specified then the standing bids of the participants for the program
     * are returned.
     * 
     * Parameters Event id this is the id of the DR event that was assigned when
     * the DR event was issued.
     * 
     * 
     * 
     * Return Values A list of Participant Bid objects for each participant in
     * the program. A true/false indicator which signifies whether the bidding
     * is still open for the event.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param eventID
     *            the event id
     * @param bids
     *            the bids
     * @param biddingOpen
     *            the bidding open
     * @param programName
     *            the program name
     * @param returnValue
     *            the return value
     */
    @WebMethod(operationName = "GetCurrentBids", action = "http://www.openadr.org/DRAS/UtilityOperator/GetCurrentBids")
    @RequestWrapper(localName = "GetCurrentBids", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetCurrentBids")
    @ResponseWrapper(localName = "GetCurrentBidsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetCurrentBidsResponse")
    public void getCurrentBids(
            @WebParam(name = "eventID", targetNamespace = "") String eventID,
            @WebParam(name = "programName", targetNamespace = "") String programName,
            @WebParam(name = "bids", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfBids> bids,
            @WebParam(name = "biddingOpen", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<Boolean> biddingOpen,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        ListOfBids ret = new ListOfBids();

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        // todo 0313 may move down to programManager
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    programName, "DESCRIPTION_UO_getCurrentBids"));

            org.openadr.dras.bid.ListOfBids bidList = new org.openadr.dras.bid.ListOfBids();
            List<DBPEvent> eventList = new ArrayList<DBPEvent>();
            if (eventID != null && !eventID.isEmpty()) {
                Event event = _eventManager.getEventWithParticipants(eventID);
                if (event instanceof DBPEvent) {
                    DBPEvent dbpEvent = (DBPEvent) event;
                    eventList.add(dbpEvent);
                }
            } else if (programName != null && !programName.isEmpty()) {
                List<EventInfo> eventInfos = programManager1
                        .getEventsForProgram(programName);
                for (EventInfo eventInfo : eventInfos) {
                    Event event = _eventManager.getEvent(
                            eventInfo.getProgramName(),
                            eventInfo.getEventName());
                    if (event instanceof DBPEvent) {
                        DBPEvent dbpEvent = (DBPEvent) event;
                        eventList.add(dbpEvent);
                    }
                }
            }

            for (DBPEvent dbpEvent : eventList) {

                // TODO lin how to decide open or close by responseBy time ?
                Date responseBy = dbpEvent.getRespondBy();
                Boolean status;
                if (responseBy.after(new Date())) {
                    status = new Boolean(true);
                } else {
                    status = new Boolean(false);
                }
                biddingOpen.value = status;
                String progName = dbpEvent.getProgramName();
                String eventName = dbpEvent.getEventName();
                List<BidEntry> bidEntries = new ArrayList<BidEntry>();

                for (EventParticipant participant : dbpEvent.getParticipants()) {
                    List<BidEntry> bidEntriesPart = dbpDataAccess.getBid(
                            progName, eventName, participant.getParticipant()
                                    .getParticipantName(), participant
                                    .getParticipant().isClient());
                    bidEntries.addAll(bidEntriesPart);
                    org.openadr.dras.bid.Bid bid = BeanMappingUtil.getBid(
                            progName, eventName, participant.getParticipant()
                                    .getAccountNumber(), bidEntries);
                    bidList.getBids().add(bid);
                }
            }
            bids.value = bidList;
            ret = bidList;
            retCode = "SUCCESS";
            returnValue.value = retCode;
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return;
    }

    /**
     * This function is used to explicitly close the bidding for a particular DR
     * event. When bidding is closed Participants can no longer submit bids.
     * When a DR Event that requires bidding is issued it has a time in which
     * the bidding will close. This function can close that bidding before that
     * time. It is also recommended that it be used with the PULL model to
     * insure that the bidding has closed before the Utility/ISO gets the final
     * bidding information.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param eventID
     *            the event id
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "CloseBidding", action = "http://www.openadr.org/DRAS/UtilityOperator/CloseBidding")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "CloseBidding", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.CloseBidding")
    @ResponseWrapper(localName = "CloseBiddingResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.CloseBiddingResponse")
    public String closeBidding(
            @WebParam(name = "eventID", targetNamespace = "") String eventID) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    "DESCRIPTION_UO_closeBidding"));

            List<String> parameters = new ArrayList<String>();
            parameters.add(eventID);

            // todo 0313 pm provides new method in the future
            String error = ErrorResourceUtil.getErrorMessage(
                    "ERROR_CLOSING_BID_NOT_ALLOWED", parameters);
            throw new Exception(error);
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;

        // TODO lin: currently we only support bid in DBP program. It's not a
        // program with generic bidding. DBP program doesn't support closing bid
        // exclusively.

    }

    /**
     * This function is used to notify the DRAS of which previously submitted
     * Participant Bids have been rejected and accepted.
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param rejectedBids
     *            the rejected bids
     * @param eventID
     *            the event id
     * @param acceptedBids
     *            the accepted bids
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "SetBidStatus", action = "http://www.openadr.org/DRAS/UtilityOperator/SetBidStatus")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "SetBidStatus", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.SetBidStatus")
    @ResponseWrapper(localName = "SetBidStatusResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.SetBidStatusResponse")
    public String setBidStatus(
            @WebParam(name = "eventID", targetNamespace = "") String eventID,
            @WebParam(name = "acceptedBids", targetNamespace = "") ListOfUtilityDREvents acceptedBids,
            @WebParam(name = "rejectedBids", targetNamespace = "") ListOfParticipantAccountIDs rejectedBids) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        // todo 0313 new method will be provided in pm
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    "DESCRIPTION_UO_setBidStatus"));

            List<Bid> acceptedBidList = BeanMappingUtil.getBidListForEvent(
                    acceptedBids, eventID);
            Event event = _eventManager.getEventOnly(eventID);
            if (event == null) {
                String error = ErrorResourceUtil.getErrorMessage(
                        "ERROR_EVENT_NOT_EXIST", eventID);
                throw new Exception(error);
            }
            String progName = event.getProgramName();
            List<Bid> rejectedBidList = BeanMappingUtil.getBidList(
                    rejectedBids, eventID, progName);
            dbpDataAccess.setBidStatus(acceptedBidList, rejectedBidList);

        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;
    }

    /**
     * Gets the participant list.
     * 
     * @param participants
     *            the participants
     * @param programNames
     *            the program names
     * 
     * @return the participant list
     */
    private List<Participant> getParticipantList(ParticipantList participants,
            ListOfProgramNames programNames) {
        List<String> partIdList = null;
        if (participants != null && participants.getAccounts() != null
                && participants.getAccounts().getParticipantID() != null
                && participants.getAccounts().getParticipantID().size() > 0) {
            partIdList = participants.getAccounts().getParticipantID();
        }

        List<Participant> partListResult = new ArrayList<Participant>();
        if (programNames != null && programNames.getProgramID() != null
                && programNames.getProgramID().size() > 0) {
            List<String> progNameList = programNames.getProgramID();
            for (String progName : progNameList) {
                List<Participant> partList = programParticipantManager
                        .getParticipantsForProgramAsObject(progName);
                for (Participant part : partList) {
                    if (partIdList != null) {
                        Iterator<String> it = partIdList.iterator();
                        while (it.hasNext()) {
                            String partID = (String) it.next();
                            if (partID.equals(part.getAccountNumber())) {
                                partListResult.add(part);
                                it.remove();
                                break;
                            }
                        }
                    } else {
                        partListResult.add(part);
                    }
                }
            }
        } else if (partIdList != null) {
            for (String partId : partIdList) {
                partListResult.add(participantManager
                        .getParticipantByAccount(partId));
            }
        } else {
            for (Participant particpant : participantManager
                    .getAllParticipants()) {
                partListResult.add(particpant);
            }
        }

        return partListResult;
    }

    /**
     * This function is for retrieving a DRAS Clients current communication
     * state. The states can be fetched based upon aa ParticipantAccount
     * identifier, or a Program name. If none of those parameters are specified
     * then the states of all DRAS Clients are returned
     * 
     * Authorized Users:
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param participants
     *            the participants
     * @param programNames
     *            the program names
     * @param drasClientStatus
     *            the dras client status
     * @param returnValue
     *            the return value
     * 
     *            returns java.lang.String
     */
    @WebMethod(operationName = "GetDRASClientCommsStatus", action = "http://www.openadr.org/DRAS/UtilityOperator/GetDRASClientCommsStatus")
    @RequestWrapper(localName = "GetDRASClientCommsStatus", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASClientCommsStatus")
    @ResponseWrapper(localName = "GetDRASClientCommsStatusResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASClientCommsStatusResponse")
    public void getDRASClientCommsStatus(
            @WebParam(name = "participants", targetNamespace = "") ParticipantList participants,
            @WebParam(name = "programNames", targetNamespace = "") ListOfProgramNames programNames,
            @WebParam(name = "DRASClientStatus", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfCommsStatus> drasClientStatus,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        ListOfCommsStatus ret = new ListOfCommsStatus();
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(participants,
                    programNames, "DESCRIPTION_UO_getDRASClientCommsStatus"));
            logEntry.setDescription("SUCCESS");

            for (Participant part : getParticipantList(participants,
                    programNames)) {
                CommsStatus partStatus = new CommsStatus();
                // TODO lin: not sure if we have dras client id internally, user
                // accountNumber for now.
                partStatus.setDRASClientID(part.getAccountNumber());
                ClientStatus status = participantManager.getParticipantStatus(
                        part.getParticipantName(), part.isClient());
                String statusStr = "ERRORS";
                if (status == ClientStatus.ONLINE) {
                    statusStr = "OK";
                } else if (status == ClientStatus.OFFLINE) {
                    statusStr = "OFFLINE";
                } else if (status == ClientStatus.ERROR) {
                    statusStr = "ERRORS";
                }
                partStatus.setStatus(statusStr);
                ret.getStatus().add(partStatus);
            }
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }

        drasClientStatus.value = ret;
        returnValue.value = retCode;
    }

    /**
     * This function is used to retrieve any of the transaction logs associated
     * with the DRAS. A number of search keys can be used to specify whcih
     * transactions are retrieved
     * 
     * Parameters Transaction users this is an identifier that is used to
     * specify which users were involved in the transaction. There are three
     * ways in which the users may be specified. User name(s) this is the user
     * name associated with the transaction being fetched. o Participant id(s)
     * this is the identifier of the Participant that was involved with the
     * transactions. All users including DRAS Clients that are associated with
     * that Participant are used. o DRAS Client id(s) this is an optional
     * parameter that is the identifier for the DRAS Client whose transactions
     * are being retrieved. In essence this provides a convenient way to fetch
     * the communications log for a DRAS Client. Method name this is the name of
     * the function that was invoked to create the transaction. In essence this
     * is the type of transaction. If not specified then all transactions are
     * returned. Data/time interval this is the interval of time that the
     * transactions are being retrieved for. Result this optional parameter
     * allows transactions the be retrieved based upon whether they were
     * SUCESSFUL or FAILED.
     * 
     * Return Values SUCCESS or FAILURE
     * 
     * Authorized Users: - All DRAS Operators - All Utility/ISO Operators
     * 
     * @param timeInterval
     *            the time interval
     * @param resultCode
     *            the result code
     * @param userNames
     *            the user names
     * @param participantIDs
     *            the participant i ds
     * @param methodName
     *            the method name
     * @param drasClientIDs
     *            the dras client i ds
     * @param transactions
     *            the transactions
     * @param returnValue
     *            the return value
     * 
     * @return returns logs.ListOfTransactionLogs
     */
    @WebMethod(operationName = "GetDRASTransactions", action = "http://www.openadr.org/DRAS/UtilityOperator/GetDRASTransactions")
    @RequestWrapper(localName = "GetDRASTransactions", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASTransactions")
    @ResponseWrapper(localName = "GetDRASTransactionsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASTransactionsResponse")
    public void getDRASTransactions(
            @WebParam(name = "userNames", targetNamespace = "") ListOfIDs userNames,
            @WebParam(name = "DRASClientIDs", targetNamespace = "") ListOfIDs drasClientIDs,
            @WebParam(name = "participantIDs", targetNamespace = "") ListOfIDs participantIDs,
            @WebParam(name = "methodName", targetNamespace = "") String methodName,
            @WebParam(name = "timeInterval", targetNamespace = "") DateTimeWindow timeInterval,
            @WebParam(name = "resultCode", targetNamespace = "") String resultCode,
            @WebParam(name = "transactions", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfTransactionLogs> transactions,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        // todo 0313 detail later
        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        ListOfTransactionLogs ret = null;
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(userNames,
                    drasClientIDs, participantIDs, methodName, timeInterval,
                    resultCode, "DESCRIPTION_UO_getDRASTransactions"));

            FireLogReaderBean firelogReader = new FireLogReaderBean();
            List<String> usernames = null;
            if (userNames != null && userNames.getIdentifier().size() > 0) {
                usernames = userNames.getIdentifier();
            }

            // TODO lin: since input param can't be null, I will take methodName
            // "" as null.
            if (methodName.isEmpty())
                methodName = null;
            if (timeInterval.getStartDateTime() == null) {
                throw new Exception("Start time can't be null.");
            }
            Date startTime = timeInterval.getStartDateTime()
                    .toGregorianCalendar().getTime();
            Date endTime = null;

            if (timeInterval.getEndDateTime() != null) {
                endTime = timeInterval.getEndDateTime().toGregorianCalendar()
                        .getTime();
            }

            List<FireLogEntry> logs = firelogReader.searchLog(usernames,
                    methodName, startTime, endTime);
            ret = BeanMappingUtil.getListOfTransactionLogs(logs);
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    ret, retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        transactions.value = ret;
        returnValue.value = retCode;
    }

    /**
     * This function is used to retrieve DRAS Client Alarms that have been
     * logged within the DRAS.
     * 
     * Authorized Users
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param timeInterval
     *            the time interval
     * @param participantIDs
     *            the participant i ds
     * @param drasClientIDs
     *            the dras client i ds
     * @param alarms
     *            the alarms
     * @param returnValue
     *            the return value
     * 
     *            returns logs.ListOfDRASClientAlarms
     */
    @WebMethod(operationName = "GetDRASClientAlarms", action = "http://www.openadr.org/DRAS/UtilityOperator/GetDRASClientAlarms")
    @RequestWrapper(localName = "GetDRASClientAlarms", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASClientAlarms")
    @ResponseWrapper(localName = "GetDRASClientAlarmsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASClientAlarmsResponse")
    public void getDRASClientAlarms(
            @WebParam(name = "DRASClientIDs", targetNamespace = "") ListOfIDs drasClientIDs,
            @WebParam(name = "participantIDs", targetNamespace = "") ListOfIDs participantIDs,
            @WebParam(name = "timeInterval", targetNamespace = "") DateTimeWindow timeInterval,
            @WebParam(name = "alarms", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfDRASClientAlarms> alarms,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        ListOfDRASClientAlarms ret = new ListOfDRASClientAlarms();

        // todo 0313 add new method in reader

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(drasClientIDs,
                    participantIDs, timeInterval,
                    "DESCRIPTION_UO_getDRASClientAlarms"));
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        alarms.value = ret;
        returnValue.value = retCode;

    }

    /**
     * This function is used to fetch a list of Feedback objects based upon a
     * set of search criteria
     * 
     * Authorized Users
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators.
     * 
     * @param timeInterval
     *            the time interval
     * @param name
     *            the name
     * @param participantIDs
     *            the participant i ds
     * @param drasClientIDs
     *            the dras client i ds
     * @param programNames
     *            the program names
     * @param feedback
     *            the feedback
     * @param returnValue
     *            the return value
     * 
     *            returns feedback.ListOfFeedback
     */
    @WebMethod(operationName = "GetParticipantFeedback", action = "http://www.openadr.org/DRAS/UtilityOperator/GetParticipantFeedback")
    @RequestWrapper(localName = "GetParticipantFeedback", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetParticipantFeedback")
    @ResponseWrapper(localName = "GetParticipantFeedbackResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetParticipantFeedbackResponse")
    public void getParticipantFeedback(
            @WebParam(name = "DRASClientIDs", targetNamespace = "") ListOfIDs drasClientIDs,
            @WebParam(name = "participantIDs", targetNamespace = "") ListOfIDs participantIDs,
            @WebParam(name = "programNames", targetNamespace = "") ListOfIDs programNames,
            @WebParam(name = "timeInterval", targetNamespace = "") DateTimeWindow timeInterval,
            @WebParam(name = "name", targetNamespace = "") String name,
            @WebParam(name = "feedback", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfFeedback> feedback,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        ListOfFeedback ret = new ListOfFeedback();

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        // TODO lin: not supported internally.
        // todo 0313 further discussion
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(drasClientIDs,
                    participantIDs, programNames, name, timeInterval,
                    "DESCRIPTION_UO_getParticipantFeedback"));
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        feedback.value = ret;
        returnValue.value = retCode;
    }

    /**
     * This function returns all the defined groups for all ParticipantAccounts.
     * 
     * Authorized Users
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param empty
     *            the empty
     * @param groups
     *            the groups
     * @param returnValue
     *            the return value
     * 
     *            returns utilityprogram.ListOfIDs
     */
    @WebMethod(operationName = "GetGroups", action = "http://www.openadr.org/DRAS/UtilityOperator/GetGroups")
    @RequestWrapper(localName = "GetGroups", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetGroups")
    @ResponseWrapper(localName = "GetGroupsResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetGroupsResponse")
    public void getGroups(
            @WebParam(name = "empty", targetNamespace = "") Object empty,
            @WebParam(name = "groups", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfIDs> groups,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        ListOfIDs ret = new ListOfIDs();

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            // todo 0313 get new method from pm
            // programManager.getGroup();
            logEntry.setLongDescr(StringUtil
                    .createLongDesc("DESCRIPTION_UO_getGroups"));
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        groups.value = ret;
        returnValue.value = retCode;
        // TODO lin: not implemented internally

    }

    /**
     * This is method is used to set ProgramConstraints that are applied to a
     * specific DR Event. They must adhere to the ProgramConstraints that are
     * part of a specific Program. If ProgramConstraints are set for a specific
     * DR Event then they are associated with the event identifier for that DR
     * Event and each subsequent DR Evetn with that identifier that is initiated
     * must adhere to those constraints. If there are no ProgramConstraints
     * specifically set for a DR Event then any DR Events issued will adhere to
     * the normal set of ProgramConstraints established for the Program,
     * Participants, or the DRAS Client .
     * 
     * Authorized Users
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param eventID
     *            the event id
     * @param constraint
     *            the constraint
     * 
     * @return the string
     * 
     *         returns java.lang.String
     */
    @WebMethod(operationName = "SetEventConstraint", action = "http://www.openadr.org/DRAS/UtilityOperator/SetEventConstraint")
    @WebResult(name = "returnValue", targetNamespace = "")
    @RequestWrapper(localName = "SetEventConstraint", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.SetEventConstraint")
    @ResponseWrapper(localName = "SetEventConstraintResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.SetEventConstraintResponse")
    public String setEventConstraint(
            @WebParam(name = "eventID", targetNamespace = "") String eventID,
            @WebParam(name = "constraint", targetNamespace = "") ProgramConstraint constraint) {
        String retCode = "FAILURE: ";

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    constraint, "DESCRIPTION_UO_setEventConstraint"));
            Event event = _eventManager.getEventOnly(eventID);
            Program program = programManager1
                    .getProgramOnly(event.getProgramName());
            if (program.getMaxDurationMS() / 1000 < constraint
                    .getMaxEventDuration()) {
                String error = ErrorResourceUtil
                        .getErrorMessage("ERROR_INVALID_CONSTRAINT_EXCEED_MAXDUR");
                throw new Exception(error);
            }

            if (event.getStartTime().after(
                    DateTool.converXMLGregorianCalendarToDate(constraint
                            .getEventWindow().getStartTime()))) {
                String error = ErrorResourceUtil
                        .getErrorMessage("ERROR_INVALID_CONSTRAINT_START_TOO_EARLY");
                throw new Exception(error);

            }
            String error = ErrorResourceUtil
                    .getErrorMessage("ERROR_EVENT_CONSTRAIT_CHANGE_NOT_ALLOWED");
            throw new Exception(error);

        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        return retCode;

        // TODO lin: this was added for UtilityOperator standard support.
        // comment this out
        // since the current system may not support this well.
        /*
         * String ret = "FAILURE"; try { ProgramEvent event =
         * EJBFactory.getProgramManager().getEvent(eventID); //Program program =
         * EJBFactory.getProgramManager().updateProgram();
         * //BeanMappingUtil.getProgramConstraint(program); return ret; }
         * catch(Exception e) { log.error(LogUtils.createLogEntry( "",
         * LogUtils.CATAGORY_EVENT, "getEventConstraint failed",
         * e.getLocalizedMessage()));
         * log.error(LogUtils.createExceptionLogEntry( "",
         * LogUtils.CATAGORY_EVENT, e));
         * 
         * } return ret;
         */
    }

    /**
     * This is used to fetch a ProgramConstraint that may have been set by a
     * call to the SetEventConstraint method.
     * 
     * Authorized Users
     * 
     * - All DRAS Operators
     * 
     * - All Utility/ISO Operators
     * 
     * @param eventID
     *            the event id
     * @param constraint
     *            the constraint
     * @param returnValue
     *            the return value
     * 
     *            returns programconstraint.ProgramConstraint
     */
    @WebMethod(operationName = "GetEventConstraint", action = "http://www.openadr.org/DRAS/UtilityOperator/GetEventConstraint")
    @RequestWrapper(localName = "GetEventConstraint", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetEventConstraint")
    @ResponseWrapper(localName = "GetEventConstraintResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetEventConstraintResponse")
    public void getEventConstraint(
            @WebParam(name = "eventID", targetNamespace = "") String eventID,
            @WebParam(name = "constraint", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ProgramConstraint> constraint,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        ProgramConstraint ret = new ProgramConstraint();

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventID,
                    "DESCRIPTION_UO_getEventConstraint"));

            Event event = _eventManager.getEventOnly(eventID);

            Program program = programManager1
                    .getProgramOnly(event.getProgramName());
            ret = BeanMappingUtil.getProgramConstraint(program, event);
            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        constraint.value = ret;
        returnValue.value = retCode;
    }

    /**
     * Gets the dras event states.
     * 
     * @param returnValue
     *            the return value
     * @param drasClients
     *            the dras clients
     * @param eventStates
     *            the event states
     * @param eventIDs
     *            the event i ds
     * @param participants
     *            the participants
     * @param programNames
     *            the program names
     */
    @WebMethod(operationName = "GetDRASEventStates", action = "http://www.openadr.org/DRAS/UtilityOperator/GetDRASEventStates")
    @RequestWrapper(localName = "GetDRASEventStates", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASEventStates")
    @ResponseWrapper(localName = "GetDRASEventStatesResponse", targetNamespace = "http://www.openadr.org/DRAS/UtilityOperator/", className = "org.openadr.dras.utilityoperator.GetDRASEventStatesResponse")
    public void getDRASEventStates(
            @WebParam(name = "eventIDs", targetNamespace = "") ListOfEventIDs eventIDs,
            @WebParam(name = "programNames", targetNamespace = "") ListOfProgramNames programNames,
            @WebParam(name = "participants", targetNamespace = "") ParticipantList participants,
            @WebParam(name = "drasClients", targetNamespace = "") ListOfIDs drasClients,
            @WebParam(name = "eventStates", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<ListOfEventStates> eventStates,
            @WebParam(name = "returnValue", targetNamespace = "", mode = WebParam.Mode.OUT) Holder<String> returnValue) {
        String retCode = "FAILURE: ";
        ListOfEventStates ret = new ListOfEventStates();

        FireLogEntry logEntry = LogUtils.createLogEntry();
        logEntry.setCategory(LogUtils.CATAGORY_WEBSERVICE);
        // todo 0313 pm provides new methods for each filter lists
        try {
            logEntry.setLongDescr(StringUtil.createLongDesc(eventIDs,
                    programNames, participants, drasClients,
                    "DESCRIPTION_UO_getDRASEventStates"));

            List<String> partNameList = null;
            if (programNames != null && programNames.getProgramID().size() > 0) {
                for (String progName : programNames.getProgramID()) {
                    partNameList = programParticipantManager
                            .getParticipantsForProgram(progName);
                }
            }

            List<String> partNames = new ArrayList<String>();

            if (participants != null && participants.getAccounts() != null
                    && participants.getAccounts().getParticipantID().size() > 0) {
                for (String partId : participants.getAccounts()
                        .getParticipantID()) {

                    Participant pa = participantManager
                            .getParticipantByAccount(partId);
                    boolean add = true;
                    if (partNameList != null) {
                        add = false;
                        for (String partName : partNameList) {
                            if (partName.equalsIgnoreCase(pa.getUser())) {
                                add = true;
                                break;
                            }
                        }
                    }
                    if (!add)
                        continue;
                    if (add)
                        partNames.add(pa.getUser());
                }
            } else {
                partNames = partNameList;
            }

            ClientManager clientManager = EJBFactory
                    .getBean(ClientManager.class);
            for (String paName : partNames) {
                List<EventState> eventStateList = clientManager
                        .getClientEventStates(paName, false);
                ListOfEventStates eventStateListOut = BeanMappingUtil
                        .getListOfEventStates(eventStateList);
                for (org.openadr.dras.eventstate.EventState st : eventStateListOut
                        .getEventStates()) {
                    ret.getEventStates().add(st);
                }
            }

            retCode = "SUCCESS";
        } catch (Exception e) {
            logEntry.setDescription(e.getMessage());
            retCode = retCode + "TransactionID: "
                    + LogUtils.getTransactionIDFromLogEntry(logEntry)
                    + " ErrorMessage: " + e.getMessage();
            retCode = retCode + e.getMessage();
        } finally {
            String result = StringUtil.appendLongDesc(logEntry.getLongDescr(),
                    retCode);
            logEntry.setLongDescr(result);
            if ("SUCCESS".equals(retCode)) {
                log.debug(logEntry);
            } else {
                log.error(logEntry);
            }
        }
        eventStates.value = ret;
        returnValue.value = retCode;
    }

    /*
     * @WebMethod(operationName = "GetDRASClientData", action =
     * "http://www.openadr.org/DRAS/UtilityOperator/GetDRASClientData")
     * 
     * @WebResult(name = "clientData", targetNamespace = "")
     * 
     * @RequestWrapper(localName = "GetDRASClientData", targetNamespace =
     * "http://www.openadr.org/DRAS/UtilityOperator/", className =
     * "org.openadr.dras.utilityoperator.GetDRASClientData")
     * 
     * @ResponseWrapper(localName = "GetDRASClientDataResponse", targetNamespace
     * = "http://www.openadr.org/DRAS/UtilityOperator/", className =
     * "org.openadr.dras.utilityoperator.GetDRASClientDataResponse")
     * 
     * public ListofClientData getDRASClientData(
     * 
     * @WebParam(name = "participants", targetNamespace = "") ParticipantList
     * participants,
     * 
     * @WebParam(name = "programName", targetNamespace = "") ListOfProgramNames
     * programName) { String retCode = "FAILURE: "; FireLogEntry logEntry =
     * LogUtils.createLogEntry(); ListofClientData ret = new ListofClientData();
     * try { logEntry.setLongDescr(StringUtil.createLongDesc(new
     * ParticipantList(), new ListOfProgramNames(),
     * "DESCRIPTION_UO_getDRASClientData")); logEntry.setDescription("SUCCESS");
     * for (Participant part : getParticipantList(participants, programName)) {
     * ClientData clientData = new ClientData();
     * clientData.setClientID(part.getAccountNumber());
     * clientData.setPending(programManager.getParticipantSignalStateAsString(
     * part.getUser(), "pending"));
     * clientData.setMode(programManager.getParticipantSignalStateAsString(
     * part.getUser(), "mode"));
     * 
     * // last contact final Date lastContact =
     * dataAccess.getParticipantLastContact(part); if (lastContact != null) {
     * final long lastMin = (System.currentTimeMillis() - lastContact.getTime())
     * / (60 * 1000); if(lastMin < 12 * 60) // less than 12 hours {
     * clientData.setLastContact(Long.toString(lastMin) + " mins " + new
     * SimpleDateFormat("HH:mm"). format(lastContact)); } else {
     * clientData.setLastContact( new SimpleDateFormat("MM/dd/yy HH:mm").
     * format(lastContact)); } } else { clientData.setLastContact(""); }
     * 
     * clientData.setAveShedPerHour(part.getShedPerHourKW());
     * 
     * // status Participant.Status status =
     * programManager.getParticipantStatus(part.getUser()); String statusStr =
     * "ERRORS"; if (status == Participant.Status.ONLINE) { statusStr = "OK"; }
     * else if (status == Participant.Status.OFFLINE) { statusStr = "OFFLINE"; }
     * else if (status == Participant.Status.ERROR) { statusStr = "ERRORS"; }
     * clientData.setStatus(statusStr);
     * 
     * clientData.setMySiteURL("../pss2.website/mysite.do?user=" +
     * part.getUser());
     * clientData.setGraphURL("../pss2.website/usages.do?userName=" +
     * part.getUser());
     * 
     * clientData.setParam1(Double.toString(part.getLatitude()));
     * clientData.setParam2(Double.toString(part.getLongitude()));
     * 
     * ret.getData().add(clientData); } } catch (Exception e) {
     * logEntry.setDescription(e.getMessage()); retCode = retCode +
     * "TransactionID: " + LogUtils.getTransactionIDFromLogEntry(logEntry) +
     * " ErrorMessage: " + e.getMessage(); retCode = retCode + e.getMessage(); }
     * finally { String result =
     * StringUtil.appendLongDesc(logEntry.getLongDescr(), "", ret, retCode);
     * logEntry.setLongDescr(result); if ("SUCCESS".equals(retCode)) {
     * log.info(logEntry); } else { log.error(logEntry); } }
     * 
     * // return ret; return ret; }
     */
}
